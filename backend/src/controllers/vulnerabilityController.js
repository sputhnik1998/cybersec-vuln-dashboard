const Vulnerability = require('../models/Vulnerability');
const { createLogger } = require('../utils/logger');

const logger = createLogger('VulnerabilityController');

/**
 * Get all vulnerabilities with filtering, sorting, and pagination
 */
exports.getVulnerabilities = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      severity,
      status,
      packageName,
      cve,
      kaiStatus,
      sortBy = 'published',
      order = 'desc',
    } = req.query;

    const limitNum = parseInt(limit);
    const pageNum = parseInt(page);
    const skip = (pageNum - 1) * limitNum;

    logger.debug('Fetching vulnerabilities', { page: pageNum, limit: limitNum, filters: { severity, status, packageName, cve, kaiStatus } });

    // Build filter object
    const filter = {};
    if (severity) filter.severity = severity.toLowerCase();
    if (status) filter.status = { $regex: status, $options: 'i' };
    if (packageName) filter.packageName = { $regex: packageName, $options: 'i' };
    if (cve) filter.cve = { $regex: cve, $options: 'i' };

    // Handle kaiStatus filtering with exclusion support
    if (kaiStatus) {
      if (kaiStatus.includes(',')) {
        const exclusions = kaiStatus.split(',').map(val => val.trim());
        const excludeValues = exclusions
          .filter(val => val.startsWith('!'))
          .map(val => val.substring(1));

        if (excludeValues.length > 0) {
          filter.$or = [
            { kaiStatus: null },
            { kaiStatus: { $nin: excludeValues } }
          ];
        }
      } else if (kaiStatus.startsWith('!')) {
        const excludeValue = kaiStatus.substring(1);
        filter.$or = [
          { kaiStatus: null },
          { kaiStatus: { $ne: excludeValue } }
        ];
      } else {
        filter.kaiStatus = { $regex: kaiStatus, $options: 'i' };
      }
    }

    // Build sort object
    const sort = {};
    sort[sortBy] = order === 'asc' ? 1 : -1;
    sort._id = order === 'asc' ? 1 : -1;

    // Execute queries in parallel
    const [vulnerabilities, totalCount] = await Promise.all([
      Vulnerability.find(filter)
        .sort(sort)
        .skip(skip)
        .limit(limitNum)
        .select('cve severity cvss status kaiStatus packageName packageVersion published fixDate')
        .lean(),
      Vulnerability.countDocuments(filter),
    ]);

    const totalPages = Math.ceil(totalCount / limitNum);

    logger.debug('Vulnerabilities fetched', { count: vulnerabilities.length, totalCount });

    res.json({
      vulnerabilities,
      pagination: {
        currentPage: pageNum,
        limit: limitNum,
        totalCount,
        totalPages,
        hasMore: pageNum < totalPages,
      },
    });
  } catch (error) {
    logger.error('Error fetching vulnerabilities', { error: error.message });
    res.status(500).json({ message: error.message });
  }
};

/**
 * Get vulnerability by ID
 */
exports.getVulnerabilityById = async (req, res) => {
  try {
    const { id } = req.params;
    logger.debug('Fetching vulnerability by ID', { id });

    const vulnerability = await Vulnerability.findById(id).lean();

    if (!vulnerability) {
      logger.warn('Vulnerability not found', { id });
      return res.status(404).json({ message: 'Vulnerability not found' });
    }

    res.json(vulnerability);
  } catch (error) {
    logger.error('Error fetching vulnerability by ID', { id: req.params.id, error: error.message });
    res.status(500).json({ message: error.message });
  }
};
