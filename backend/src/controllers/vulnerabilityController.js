const Vulnerability = require('../models/Vulnerability');

// Get all vulnerabilities with filtering, sorting, and optimized cursor pagination
exports.getVulnerabilities = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      severity,
      status,
      packageName,
      cve,
      sortBy = 'published',
      order = 'desc',
    } = req.query;

    const limitNum = parseInt(limit);
    const pageNum = parseInt(page);
    const skip = (pageNum - 1) * limitNum;

    // Build filter object
    const filter = {};
    if (severity) filter.severity = severity.toLowerCase();
    if (status) filter.status = { $regex: status, $options: 'i' };
    if (packageName) filter.packageName = { $regex: packageName, $options: 'i' };
    if (cve) filter.cve = { $regex: cve, $options: 'i' };

    // Build sort object
    const sort = {};
    sort[sortBy] = order === 'asc' ? 1 : -1;
    sort._id = order === 'asc' ? 1 : -1; // Secondary sort by _id for consistency

    // Execute queries in parallel for better performance
    const [vulnerabilities, totalCount] = await Promise.all([
      Vulnerability.find(filter)
        .sort(sort)
        .skip(skip)
        .limit(limitNum)
        .select('cve severity cvss status packageName packageVersion published fixDate')
        .lean(),
      Vulnerability.countDocuments(filter),
    ]);

    const totalPages = Math.ceil(totalCount / limitNum);

    res.json({
      vulnerabilities,
      pagination: {
        currentPage: pageNum,
        limit: limitNum,
        totalCount,
        totalPages,
        hasMore: pageNum < totalPages,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get vulnerability by ID
exports.getVulnerabilityById = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id);

    if (!vulnerability) {
      return res.status(404).json({ message: 'Vulnerability not found' });
    }

    res.json(vulnerability);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get dashboard statistics
exports.getDashboardStats = async (req, res) => {
  try {
    const [
      totalCount,
      severityStats,
      affectedRepos,
      fixedStats,
    ] = await Promise.all([
      // Total vulnerabilities
      Vulnerability.countDocuments(),

      // Count by severity
      Vulnerability.aggregate([
        {
          $group: {
            _id: '$severity',
            count: { $sum: 1 },
          },
        },
      ]),

      // Count affected repositories/packages
      Vulnerability.distinct('packageName'),

      // Fixed vulnerabilities
      Vulnerability.aggregate([
        {
          $group: {
            _id: null,
            total: { $sum: 1 },
            fixed: {
              $sum: {
                $cond: [
                  { $regexMatch: { input: '$status', regex: /fixed/i } },
                  1,
                  0,
                ],
              },
            },
          },
        },
      ]),
    ]);

    // Format severity stats
    const severityMap = severityStats.reduce((acc, item) => {
      acc[item._id] = item.count;
      return acc;
    }, {});

    // Calculate fix percentage
    const fixedPercentage = fixedStats.length > 0
      ? Math.round((fixedStats[0].fixed / fixedStats[0].total) * 100)
      : 0;

    res.json({
      total: totalCount,
      affectedRepositories: affectedRepos.length,
      fixedPercentage,
      severityBreakdown: {
        critical: severityMap.critical || 0,
        high: severityMap.high || 0,
        medium: severityMap.medium || 0,
        low: severityMap.low || 0,
      },
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get vulnerabilities over time
exports.getVulnerabilitiesOverTime = async (req, res) => {
  try {
    const { months = 12 } = req.query;

    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - months);

    const timeline = await Vulnerability.aggregate([
      {
        $match: {
          published: { $gte: startDate },
        },
      },
      {
        $group: {
          _id: {
            year: { $year: '$published' },
            month: { $month: '$published' },
          },
          count: { $sum: 1 },
        },
      },
      {
        $sort: { '_id.year': 1, '_id.month': 1 },
      },
    ]);

    res.json(timeline);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get risk factors summary (optimized with aggregation)
exports.getRiskFactors = async (req, res) => {
  try {
    // Use aggregation pipeline for better performance - processes data in MongoDB
    const riskFactors = await Vulnerability.aggregate([
      // Only process documents that have riskFactors
      {
        $match: {
          riskFactors: { $exists: true, $ne: null }
        }
      },
      // Convert the Map to an array of key-value pairs
      {
        $project: {
          riskFactorKeys: { $objectToArray: '$riskFactors' }
        }
      },
      // Unwind the array to create a document for each risk factor
      {
        $unwind: '$riskFactorKeys'
      },
      // Group by risk factor name and count occurrences
      {
        $group: {
          _id: '$riskFactorKeys.k',
          count: { $sum: 1 }
        }
      },
      // Sort by count descending
      {
        $sort: { count: -1 }
      },
      // Limit to top 10
      {
        $limit: 10
      },
      // Format the output
      {
        $project: {
          _id: 0,
          name: '$_id',
          count: 1
        }
      }
    ]);

    res.json(riskFactors);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
