import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableRow,
  Paper,
  Box,
  Typography,
} from '@mui/material';
import type { SelectChangeEvent } from '@mui/material';
import { useAppDispatch, useAppSelector } from '../../../store';
import { fetchVulnerabilities, setSorting, setCurrentPage, setRowsPerPage } from '../../../store/vulnerabilitiesSlice';
import { VulnerabilityTableHeader } from './TableHeader';
import { VulnerabilityRow } from './VulnerabilityRow';
import { TablePagination } from './TablePagination';
import type { SortableColumn } from './types';
import './VulnerabilityTable.css';

const MAX_PAGE_JUMP = 10;

export const VulnerabilityTable = () => {
  const dispatch = useAppDispatch();

  // Get data from Redux store including pagination state
  const { items: vulnerabilities, pagination, loading, error, sortBy, sortOrder, currentPage, rowsPerPage } = useAppSelector(
    (state) => state.vulnerabilities
  );

  const page = currentPage;

  const totalCount = pagination?.totalCount ?? 0;
  const totalPages = pagination?.totalPages ?? 0;

  // Handle page navigation with max jump validation
  const handleChangePage = (newPage: number) => {
    if (newPage < 1 || newPage > totalPages || loading) return;

    if (Math.abs(newPage - page) > MAX_PAGE_JUMP) {
      alert(`You can only jump a maximum of ${MAX_PAGE_JUMP} pages at a time. Please navigate incrementally.`);
      return;
    }

    dispatch(setCurrentPage(newPage));
    dispatch(
      fetchVulnerabilities({
        page: newPage,
        limit: rowsPerPage,
        sortBy,
        order: sortOrder,
      })
    );
  };

  // Handle rows per page change
  const handleChangeRowsPerPage = (event: SelectChangeEvent<number>) => {
    const newLimit = Number(event.target.value);
    dispatch(setRowsPerPage(newLimit));
    dispatch(
      fetchVulnerabilities({
        page: 1,
        limit: newLimit,
        sortBy,
        order: sortOrder,
      })
    );
  };

  // Handle column sorting
  const handleSort = (column: SortableColumn) => {
    const isAsc = sortBy === column && sortOrder === 'asc';
    const newOrder = isAsc ? 'desc' : 'asc';

    dispatch(setSorting({ sortBy: column, sortOrder: newOrder }));
    dispatch(setCurrentPage(1));
    dispatch(
      fetchVulnerabilities({
        page: 1,
        limit: rowsPerPage,
        sortBy: column,
        order: newOrder,
      })
    );
  };

  // Error state
  if (error) {
    return (
      <Paper className="vulnerability-table__error" sx={{ backgroundColor: '#1a1a1a' }}>
        <Typography variant="body1" color="error">
          Error loading vulnerabilities: {error}
        </Typography>
      </Paper>
    );
  }

  return (
    <Box className="vulnerability-table">
      <TableContainer component={Paper} elevation={2} sx={{ backgroundColor: '#1a1a1a' }}>
        <Table sx={{ tableLayout: 'fixed', width: '100%' }}>
          <VulnerabilityTableHeader sortBy={sortBy} sortOrder={sortOrder} onSort={handleSort} />

          <TableBody>
            {vulnerabilities && vulnerabilities.length > 0 ? (
              vulnerabilities.map((vuln, index) => (
                <VulnerabilityRow key={vuln._id} vulnerability={vuln} index={index} />
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={7} align="center" sx={{ py: 8 }}>
                  <Typography variant="body1" color="text.secondary" sx={{ fontSize: '0.95rem' }}>
                    No vulnerabilities found
                  </Typography>
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </TableContainer>

      <TablePagination
        page={page}
        rowsPerPage={rowsPerPage}
        totalCount={totalCount}
        totalPages={totalPages}
        loading={loading}
        onPageChange={handleChangePage}
        onRowsPerPageChange={handleChangeRowsPerPage}
      />
    </Box>
  );
};
